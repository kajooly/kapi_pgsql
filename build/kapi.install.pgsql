-- Generated by Builder



 -------------------- 
 -- src/00.00.install.extensions.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- kapi required extensions 
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

 -------------------- 
 -- src/datatypes/00.01.dtd.domains.base.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


---------------------------------------------------------------
-- epoch
-- Base epoch in milliseconds since the UNIX epoch.
---------------------------------------------------------------

DROP DOMAIN IF EXISTS public.kapi_dtd_epoch;
CREATE DOMAIN public.kapi_dtd_epoch bigint 
NOT NULL 
CHECK (char_length(VALUE::text) = 13)
;

DROP DOMAIN IF EXISTS public.kapi_dtd_epoch_auto;
CREATE DOMAIN public.kapi_dtd_epoch_auto bigint 
NOT NULL 
DEFAULT ((date_part('epoch'::text, CURRENT_TIMESTAMP AT TIME ZONE 'UTC') * (1000)::double precision))::bigint
CHECK (char_length(VALUE::text) = 13)
;

DROP DOMAIN IF EXISTS public.kapi_dtd_epoch_seconds;
CREATE DOMAIN public.kapi_dtd_epoch_seconds bigint 
NOT NULL 
CHECK (char_length(VALUE::text) = 10)
;

DROP DOMAIN IF EXISTS public.kapi_dtd_epoch_seconds_auto;
CREATE DOMAIN public.kapi_dtd_epoch_seconds_auto bigint 
NOT NULL 
DEFAULT ((date_part('epoch'::text, CURRENT_TIMESTAMP AT TIME ZONE 'UTC')))::bigint
CHECK (char_length(VALUE::text) = 10)
;

---------------------------------------------------------------
-- timestamp
-- Base timestamp in milliseconds AT TIME ZONE 'UTC'
-- Format 
-- SELECT 
-- CURRENT_TIMESTAMP AT TIME ZONE 'UTC',
-- TO_CHAR((CURRENT_TIMESTAMP AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS')::timestamp,
-- TO_CHAR((CURRENT_TIMESTAMP AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS.MS')::timestamp
---------------------------------------------------------------


DROP DOMAIN IF EXISTS public.kapi_dtd_timestamp;
CREATE DOMAIN public.kapi_dtd_timestamp timestamp NOT NULL
;

DROP DOMAIN IF EXISTS public.kapi_dtd_timestamp_auto;
CREATE DOMAIN public.kapi_dtd_timestamp_auto timestamp 
NOT NULL 
DEFAULT TO_CHAR((CURRENT_TIMESTAMP AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS.MS')::timestamp 
;

DROP DOMAIN IF EXISTS public.kapi_dtd_timestamp_seconds_auto;
CREATE DOMAIN public.kapi_dtd_timestamp_seconds_auto timestamp 
NOT NULL 
DEFAULT TO_CHAR((CURRENT_TIMESTAMP AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS')::timestamp 
-- CHECK (char_length(VALUE::text) = 19)
;

DROP DOMAIN IF EXISTS public.kapi_dtd_timestamp_naive_auto;
CREATE DOMAIN public.kapi_dtd_timestamp_naive_auto timestamp 
NOT NULL 
DEFAULT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC')::timestamp
;
COMMENT ON DOMAIN public.kapi_dtd_timestamp_naive_auto IS 'length > 23, match full timestamp precision  i.e: 2022-07-05 11:08:04.826507';

---------------------------------------------------------------
-- uuid v4
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_uuid;
CREATE DOMAIN public.kapi_dtd_uuid uuid NOT NULL;

DROP DOMAIN IF EXISTS public.kapi_dtd_uuid_auto;
CREATE DOMAIN public.kapi_dtd_uuid_auto uuid NOT NULL DEFAULT uuid_generate_v4();

DROP DOMAIN IF EXISTS public.kapi_dtd_uuid_default;
CREATE DOMAIN public.kapi_dtd_uuid_default uuid NOT NULL DEFAULT '00000000-0000-0000-0000-000000000000';

---------------------------------------------------------------
-- jsonb
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_json;
CREATE DOMAIN public.kapi_dtd_json jsonb NOT NULL;

DROP DOMAIN IF EXISTS public.kapi_dtd_json_default;
CREATE DOMAIN public.kapi_dtd_json_default jsonb NOT NULL DEFAULT '{}'::jsonb;

---------------------------------------------------------------
-- ltree
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_ltree;
CREATE DOMAIN public.kapi_dtd_ltree ltree NOT NULL;

---------------------------------------------------------------
-- citext
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_citext;
CREATE DOMAIN public.kapi_dtd_citext citext NOT NULL;

DROP DOMAIN IF EXISTS public.kapi_dtd_citext_default;
CREATE DOMAIN public.kapi_dtd_citext_default citext 
NOT NULL
DEFAULT 'undefined'::citext
;

-- 'a a'  OK
-- '             a a          '  Error
DROP DOMAIN IF EXISTS public.kapi_dtd_citext_notempty;
CREATE DOMAIN public.kapi_dtd_citext_notempty citext
NOT NULL
CHECK (LENGTH(TRIM(VALUE)) = LENGTH(VALUE))
;

-- 'a a'  OK
-- '             a a          '  Error
DROP DOMAIN IF EXISTS public.kapi_dtd_citext_notempty_default;
CREATE DOMAIN public.kapi_dtd_citext_notempty_default citext
NOT NULL
DEFAULT 'undefined'::citext
CHECK (LENGTH(TRIM(VALUE)) = LENGTH(VALUE))
;

-- 'a a'  OK
-- '             a a           '  OK
DROP DOMAIN IF EXISTS public.kapi_dtd_citext_null_or_notempty;
CREATE DOMAIN public.kapi_dtd_citext_null_or_notempty citext
CHECK ((LENGTH(TRIM(VALUE)) > 0) OR VALUE IS NULL)
;

---------------------------------------------------------------
-- integer
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_int;
CREATE DOMAIN public.kapi_dtd_int integer NOT NULL;

DROP DOMAIN IF EXISTS public.kapi_dtd_int_default;
CREATE DOMAIN public.kapi_dtd_int_default integer NOT NULL DEFAULT 0;

---------------------------------------------------------------
-- text
---------------------------------------------------------------
DROP DOMAIN IF EXISTS public.kapi_dtd_text;
CREATE DOMAIN public.kapi_dtd_text text NOT NULL;

DROP DOMAIN IF EXISTS public.kapi_dtd_text_default;
CREATE DOMAIN public.kapi_dtd_text_default text 
NOT NULL
DEFAULT 'undefined'::text
;

-- 'a a'  OK
-- '             a a          '  Error
DROP DOMAIN IF EXISTS public.kapi_dtd_text_notempty;
CREATE DOMAIN public.kapi_dtd_text_notempty text
NOT NULL
CHECK (LENGTH(TRIM(VALUE)) = LENGTH(VALUE))
;

-- 'a a'  OK
-- '             a a          '  Error
DROP DOMAIN IF EXISTS public.kapi_dtd_text_notempty_default;
CREATE DOMAIN public.kapi_dtd_text_notempty_default text
NOT NULL
DEFAULT 'undefined'::text
CHECK (LENGTH(TRIM(VALUE)) = LENGTH(VALUE))
;

-- 'a a'  OK
-- '             a a           '  OK
DROP DOMAIN IF EXISTS public.kapi_dtd_text_null_or_notempty;
CREATE DOMAIN public.kapi_dtd_text_null_or_notempty text
CHECK ((LENGTH(TRIM(VALUE)) > 0) OR VALUE IS NULL)
;

 -------------------- 
 -- src/tablefunc/00.01.table.functions.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


-- FUNCION: public.kapi_tablefunc_updatedat
-- DESCRIPTION: This Trigger Function is used to update the date of the last update of the table.
-- USAGE: 
-- SELECT public.kapi_tablefunc_updatedat('categories','brands_data','node_updated_at');
-- SELECT public.kapi_tablefunc_updatedat('categories','brands_data');
DROP FUNCTION IF EXISTS public.kapi_tablefunc_updatedat;
CREATE OR REPLACE FUNCTION public.kapi_tablefunc_updatedat(
    _schema varchar, 
    _table varchar,
    _updatedat_column varchar DEFAULT 'updated_at'
)
RETURNS VOID
LANGUAGE plpgsql
VOLATILE
COST 100
AS
$$
DECLARE
    _table_name varchar default  _table;
    _table_name_full varchar default _schema || '.' || _table;
BEGIN
    EXECUTE '
	CREATE OR REPLACE FUNCTION ' || _schema || '.' || _table_name || '_trg_fn_b4_update_updatedat()
	RETURNS trigger 
	AS 
	$BODY$ 
	BEGIN
      -- Now epoch time in milliseconds or default to current time
	  NEW.' || _updatedat_column || ' =  public.kapi_time_epoch_now();
	  RETURN NEW;
	END;
	$BODY$ 
    LANGUAGE plpgsql
	;
	';

    EXECUTE	'
	DROP TRIGGER IF EXISTS trg_updatedat ON ' || _table_name_full || ';
	CREATE TRIGGER trg_updatedat
	BEFORE UPDATE 
	ON ' || _table_name_full || '
	FOR EACH ROW
	EXECUTE PROCEDURE ' || _schema || '.' || _table || '_trg_fn_b4_update_updatedat();
	';
END;
$$;


-- FUNCION: public.kapi_tablefunc_mvw_refresh
-- DESCRIPTION: This Trigger Function is used to update the date of the last update of the table.
-- USAGE: 
-- SELECT public.kapi_tablefunc_mvw_refresh('categories.brands_nodes','categories','brands_tree');
DROP FUNCTION IF EXISTS public.kapi_tablefunc_mvw_refresh;
CREATE OR REPLACE FUNCTION public.kapi_tablefunc_mvw_refresh(
    _source varchar,
    _view_schema varchar,
    _view varchar
)
RETURNS VOID
LANGUAGE plpgsql
VOLATILE
COST 100
AS
$$
DECLARE
    _table_name_full varchar default _source;
    _view_name varchar default  _view;
    _view_name_full varchar default _view_schema || '.' || _view;
    _func_name_full varchar default  _table_name_full || '_trg_mvw_refresh_' || _view_name || '()';
BEGIN
    EXECUTE '
	CREATE OR REPLACE FUNCTION ' || _func_name_full || ' 
	RETURNS trigger 
	AS 
	$t$ 
	BEGIN
	  REFRESH MATERIALIZED VIEW ' || _view_name_full || ';
	  RETURN NULL;
	END;
	$t$ LANGUAGE plpgsql
    ;
	';
		
	EXECUTE	'
	DROP TRIGGER IF EXISTS refresh_mvw_trg_' || _view_name || ' ON ' || _table_name_full || ';
	CREATE TRIGGER tree_refresh_mvw_trg
	AFTER INSERT OR UPDATE OR DELETE
	ON ' || _table_name_full || '
	FOR EACH STATEMENT
	EXECUTE PROCEDURE ' || _func_name_full || ';
	';
END;
$$;



 -------------------- 
 -- src/time/00.01.time.convertions.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
@module kapi_time
Functions for Date & Time management
context: Common functions
*/


-- @function kapi_time_epoch_to_timestamp
-- @description Convert Epoch in Milliseconds to Timestamp Without Timezone in Milliseconds
-- @param _epoch_milliseconds bigint, Epoch in Milliseconds ( 13 digits )
-- @return _timestamp timestamp, Timestamp withour timezone in Milliseconds ( YYYY-MM-DD HH24:MI:SS.MS )
-- @usage
-- Epoch of CurrentTimestamp in milliseconds
-- SELECT kapi_time_epoch_to_timestamp( (date_part('epoch'::text, CURRENT_TIMESTAMP) * (1000)::double precision)::bigint );
-- Epoch in milliseconds to Timestamp in milliseconds
-- SELECT kapi_time_epoch_to_timestamp( 1656632664923 );  -- Timestamp in milliseconds = '2022-06-30 23:44:24.923'

DROP FUNCTION IF EXISTS public.kapi_time_epoch_to_timestamp;
CREATE OR REPLACE FUNCTION public.kapi_time_epoch_to_timestamp(
        _epoch_milliseconds bigint 
    )
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS
$$
    DECLARE
        _timezone varchar default 'UTC';
        _timestamp timestamp;
        _divisor int default 1000;
    BEGIN 
        _timestamp = (to_timestamp(TO_CHAR(TO_TIMESTAMP(_epoch_milliseconds / _divisor), 'YYYY-MM-DD HH24:MI:SS') || '.' || (_epoch_milliseconds % _divisor), 'YYYY-MM-DD HH24:MI:SS.MS')) AT TIME ZONE _timezone;
        RETURN _timestamp::timestamp;
    END;
$$;

-- @function kapi_time_timestamp_to_epoch
-- @description Convert Timestamp Without Timezone in Milliseconds to Epoch in Milliseconds
-- @param _timestamp timestamp, Timestamp withour timezone in Milliseconds ( YYYY-MM-DD HH24:MI:SS.MS )
-- @return _epoch_milliseconds bigint, Epoch in Milliseconds ( 13 digits )
-- @usage
-- epoch of CurrentTimestamp in milliseconds
-- SELECT kapi_time_timestamp_to_epoch(  CURRENT_TIMESTAMP::timestamp );
-- Timestamp in milliseconds to Epoch in milliseconds
-- SELECT kapi_time_timestamp_to_epoch( '2022-06-30 23:44:24.923' );  -- epoch in milliseconds = 1656632664923

DROP FUNCTION IF EXISTS public.kapi_time_timestamp_to_epoch;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp_to_epoch(
        _timestamp timestamp 
    )
    RETURNS bigint
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS
$$
DECLARE
    _timezone varchar default 'UTC';
    _epoch_milliseconds bigint;
    _divisor int default 1000;
BEGIN
    _epoch_milliseconds = ((date_part('epoch'::text, _timestamp AT TIME ZONE _timezone) * (_divisor)::double precision))::bigint;
    RETURN _epoch_milliseconds;
END;
$$;



 -------------------- 
 -- src/time/00.01.time.epoch.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


---------------------------------------------------------------
-- Epoch time functions
-- MAIN FUNCTION: public.kapi_time_epoch
---------------------------------------------------------------

-- FUNCTION: public.kapi_time_epoch_now
-- DESCRIPTION: Returns the current epoch time in milliseconds, TZ UTC
-- RETURNS: 
-- bigint, 13 digits epoch time in milliseconds ie: 1658327306754
-- SELECT public.kapi_time_epoch_now();
DROP FUNCTION IF EXISTS public.kapi_time_epoch_now;
CREATE OR REPLACE FUNCTION public.kapi_time_epoch_now()
    RETURNS bigint
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
    DECLARE
        _result bigint;
    BEGIN
        _result = ((date_part('epoch'::text, CURRENT_TIMESTAMP AT TIME ZONE 'UTC') * (1000)::double precision))::bigint;
        RETURN _result;
    END;
$BODY$;

 -------------------- 
 -- src/time/00.01.time.timestamp.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.


--------------------------------------------------------------

-- SELECT public.kapi_time_timestamp_now();
DROP FUNCTION IF EXISTS public.kapi_time_timestamp_now;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp_now()
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
    DECLARE
        _result timestamp;
    BEGIN
        _result = TO_CHAR((CURRENT_TIMESTAMP AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS.MS')::timestamp;
        RETURN _result;
    END;
$BODY$;


---------------------------------------------------------------
-- TimeStamp Functions get or format timestamp
-- ISO 8601 format
-- Default timestamp in milliseconds & UTC timezone
-- MAIN FUNCTION: public.kapi_time_timestamp
-- Refer to timezones: select * from pg_timezone_names;
-- some examples
-- SELECT (now()::TIMESTAMP WITH TIME ZONE at time zone 'America/mexico_city')::TIMESTAMP WITH TIME ZONE ;
-- SELECT now()::timestamp at time zone 'UTC' at time zone 'America/mexico_city';
-- SELECT timezone('America/mexico_city',now()::timestamptz);
---------------------------------------------------------------

-- FUNCTION: public.kapi_time_timestamp_seconds
-- i.e: 2022-07-05 14:45:08
-- SELECT public.kapi_time_timestamp_seconds('2022-07-23 11:57:07.115713 America/mexico_city');
-- SELECT public.kapi_time_timestamp_seconds('2022-07-23 11:41:23.113887+00');
-- SELECT public.kapi_time_timestamp_seconds('Wed 17 Dec 07:37:16 1997 PST');
-- SELECT public.kapi_time_timestamp_seconds('2004-10-19 10:23:54+02');
-- SELECT public.kapi_time_timestamp_seconds('1999-01-08 04:05:06 -8:00');
-- SELECT public.kapi_time_timestamp_seconds('2022-07-05 14:45:08.471898');
-- SELECT public.kapi_time_timestamp_seconds();
DROP FUNCTION IF EXISTS public.kapi_time_timestamp_seconds;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp_seconds(
    _timestamp timestamptz DEFAULT CURRENT_TIMESTAMP
    )
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
DECLARE
	_result timestamp;
BEGIN
    _result = TO_CHAR((_timestamp AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS')::timestamp ;
    RETURN _result;
END;
$BODY$;

-- FUNCTION: public.kapi_time_timestamp_milliseconds
-- i.e: 2022-07-05 14:45:08.471
-- SELECT public.kapi_time_timestamp_milliseconds('2022-07-05 14:45:08.471898');
-- SELECT public.kapi_time_timestamp_milliseconds();
DROP FUNCTION IF EXISTS public.kapi_time_timestamp_milliseconds;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp_milliseconds(
    _timestamp timestamptz DEFAULT CURRENT_TIMESTAMP
    )
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
DECLARE
	_result timestamp;
BEGIN
    _result = TO_CHAR((_timestamp AT TIME ZONE 'UTC'), 'YYYY-MM-DD HH24:MI:SS.MS')::timestamp; 
    RETURN _result;
END;
$BODY$;

-- FUNCTION: public.kapi_time_timestamp_naive
-- i.e: 2022-07-05 14:45:08.471898
-- SELECT public.kapi_time_timestamp_naive('2022-07-05 14:45:08.471898');
-- SELECT public.kapi_time_timestamp_naive();
DROP FUNCTION IF EXISTS public.kapi_time_timestamp_naive;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp_naive(
    _timestamp timestamptz DEFAULT CURRENT_TIMESTAMP
    )
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
DECLARE
	_result timestamp;
BEGIN
    _result = (_timestamp AT TIME ZONE 'UTC')::timestamp ;
    RETURN _result;
END;
$BODY$;

-- @description: Default timestamp in milliseconds & UTC timezone
-- FUNCTION: public.kapi_time_timestamp
-- SELECT public.kapi_time_timestamp('2022-07-05 14:45:08.471898');
-- SELECT public.kapi_time_timestamp();
DROP FUNCTION IF EXISTS public.kapi_time_timestamp;
CREATE OR REPLACE FUNCTION public.kapi_time_timestamp(
    _timestamp timestamptz DEFAULT CURRENT_TIMESTAMP
    )
    RETURNS timestamp
    LANGUAGE plpgsql
    STABLE PARALLEL SAFE
    COST 1
AS $BODY$
DECLARE
	_result timestamp;
BEGIN
    _result = public.kapi_time_timestamp_milliseconds(_timestamp);
    RETURN _result;
END;
$BODY$;

---------------------------------------------------------------
-- End OF TimeStamp FORMAT Functions
---------------------------------------------------------------

 -------------------- 
 -- src/tree/structures/01.01.tree.structure.table.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
 * kapi_tree structures table functions
 * Functions for basic tree structures
 * context: Tree Structure Table
 **/


-- @function kapi_tree_structure_new_nodes
-- @description 
-- Creates a new structure table


-- Is highly recommended to use this table just for tree operations, not for data operations or biz logic

-- @param _schema The schema name
-- @param _table The table name
-- @param _suffix The suffix to add to the table name default _tree_nodes
-- @return create a new table in the schema and will sufix _tree_nodes [_schema].[_table][suffix]
-- @usage
-- SELECT kapi_tree_structure_new_nodes('categories','brands');

DROP FUNCTION IF EXISTS public.kapi_tree_structure_new_nodes;
CREATE OR REPLACE FUNCTION public.kapi_tree_structure_new_nodes(
    _schema varchar, 
    _table varchar
    ) 
RETURNS VOID
AS
$$
DECLARE
    _suffix varchar DEFAULT '_nodes';
    _table_name varchar default  _table || _suffix;
    _table_name_full varchar default _schema || '.' || _table || _suffix;
BEGIN
    -- Verify that the schema exists in the database
	EXECUTE '
	CREATE SCHEMA IF NOT EXISTS ' || _schema || ';
    ';
	
	EXECUTE '
	CREATE TABLE IF NOT EXISTS ' || _table_name_full || '(
        node_id kapi_dtd_uuid_auto,
        CONSTRAINT _pk_' || _table_name || ' PRIMARY KEY (node_id),

        node_group_id kapi_dtd_uuid_default,

        -- REQUIRED ----------------------------------------- 
        -- uniques one per level per group
        -- --------------------------------------------------
        -- TODO: change ltree to kapi when dls resolved
        -- node_path kapi_dtd_ltree,
        node_path ltree NOT NULL,
        node_key kapi_dtd_citext_notempty,
        node_alias kapi_dtd_citext_notempty,
        -- --------------------------------------------------
        -- --------------------------------------------------
       
        -- GENERATED ---------------------------------------
        -- This columns are generated on the fly, cant be updated or inserted
        -- --------------------------------------------------
        node_path_to ltree GENERATED ALWAYS AS (subltree(node_path,0,nlevel(node_path) -1 )) STORED,
        node_name ltree GENERATED ALWAYS AS (subpath(node_path, -1 )) STORED,
		node_depth bigint GENERATED ALWAYS AS (nlevel(node_path)::bigint) STORED,
       
        -- Base columns ------------------------------------
        node_weight kapi_dtd_int_default,
        node_metadata kapi_dtd_json_default,
        node_data kapi_dtd_json_default,

        node_link_weight kapi_dtd_int_default,
        node_link_metadata kapi_dtd_json_default,
        node_link_data kapi_dtd_json_default,


        -- Date and time ------------------------------------
        node_inserted_at kapi_dtd_epoch_auto,
        node_updated_at kapi_dtd_epoch_auto,

        -- CONSTRAINTS --------------------------------------
        CONSTRAINT _uk_group_node_path_' || _table_name || ' UNIQUE (node_group_id, node_path),
		CONSTRAINT _uk_group_parent_node_alias_' || _table_name || ' UNIQUE (node_group_id, node_path_to, node_alias),
		CONSTRAINT _uk_group_parent_key_' || _table_name || ' UNIQUE (node_group_id, node_path_to, node_key)

    );           
	
	CREATE INDEX IF NOT EXISTS _idx_path_' || _table_name || '  ON ' || _table_name_full || ' USING gist (node_path);
    CREATE INDEX IF NOT EXISTS _idx_path_to_' || _table_name || '  ON ' || _table_name_full || ' USING gist (node_path_to);
	CREATE INDEX IF NOT EXISTS _idx_group_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id);
    CREATE INDEX IF NOT EXISTS _idx_group_path_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_path);
    CREATE INDEX IF NOT EXISTS _idx_node_inserted_at_' || _table_name || ' ON ' || _table_name_full || ' (node_inserted_at);
    CREATE INDEX IF NOT EXISTS _idx_node_updated_at_' || _table_name || ' ON ' || _table_name_full || ' (node_updated_at);
    CREATE INDEX IF NOT EXISTS _idx_group_node_key_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_key);
    CREATE INDEX IF NOT EXISTS _idx_group_node_alias_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_alias);
    CREATE INDEX IF NOT EXISTS _idx_node_key_node_alias_fst_' || _table_name || ' ON ' || _table_name_full || ' USING gist (node_key, node_alias);
    CREATE INDEX IF NOT EXISTS _idx_node_key_node_alias_path_fst_' || _table_name || ' ON ' || _table_name_full || ' USING gist (node_key, node_alias, node_path);
	
	';

    EXECUTE '
	SELECT public.kapi_tablefunc_updatedat(''' || _schema || ''', ''' || _table_name || ''' ,''node_updated_at'');
    ';
END;
$$
LANGUAGE plpgsql;


-- @function kapi_tree_structure_new_nodes
-- @description 
-- Creates a default data structure table
--
-- Is highly recommended to use this table just for data operations or biz logic
-- and Alter to your needs just link the table to the nodes table
-- 
-- data_:: if you need Unique values per level per group add them to the nodes table

-- @TODO: Add support for One to One relationship via DEFERRABLE and Transaction commits 
-- When our common DSL(Ecto) and ORM supports it
-- ALTER TABLE nodes
--         ADD FOREIGN KEY (id) REFERENCES data(id)
--                 DEFERRABLE INITIALLY DEFERRED;
-- ALTER TABLE data
--         ADD FOREIGN KEY (id) REFERENCES nodes(id)
--                 DEFERRABLE INITIALLY DEFERRED;
-- BEGIN transaction;
-- INSERT INTO nodes VALUES (1, ...);
-- INSERT INTO data VALUES (1, ....);
-- COMMIT;

-- @param _schema The schema name
-- @param _table The table name
-- @param _suffix The suffix to add to the table name default _tree_nodes
-- @return create a new table in the schema and will sufix _tree_nodes [_schema].[_table][suffix]
-- @usage
-- SELECT kapi_tree_structure_new_data('categories.brands_nodes','categories','brands', 'citext NOT NULL','MATCH SIMPLE ON DELETE RESTRICT ON UPDATE CASCADE');
-- SELECT kapi_tree_structure_new_data('categories.brands_nodes','categories','brands', 'numeric');
-- SELECT kapi_tree_structure_new_data('categories.brands_nodes','categories','brands');
DROP FUNCTION IF EXISTS public.kapi_tree_structure_new_data;
CREATE OR REPLACE FUNCTION public.kapi_tree_structure_new_data(
    _nodes_table varchar,
    _schema varchar, 
    _table varchar,
    _value_declaration varchar DEFAULT 'kapi_dtd_citext_null_or_notempty',
    _reference_declaration varchar DEFAULT 'MATCH SIMPLE ON DELETE CASCADE ON UPDATE CASCADE'
    ) 
RETURNS VOID
AS
$$
DECLARE
    _suffix varchar DEFAULT '_data';
    _table_name varchar default  _table || _suffix;
    _table_name_full varchar default _schema || '.' || _table || _suffix;
BEGIN
    -- Verify that the schema exists in the database
	EXECUTE '
	CREATE SCHEMA IF NOT EXISTS ' || _schema || ';
    ';
	
	EXECUTE '
	CREATE TABLE IF NOT EXISTS ' || _table_name_full || '(
        data_id kapi_dtd_uuid_auto,
        CONSTRAINT _pk_' || _table_name || ' PRIMARY KEY (data_id),           
		
        data_node_id kapi_dtd_uuid,
        CONSTRAINT _uk_one_to_one_' || _table_name || ' UNIQUE (data_node_id), 
        CONSTRAINT _fk_one_to_one_' || _table_name || ' FOREIGN KEY (data_node_id) REFERENCES ' || _nodes_table || ' (node_id) ' || _reference_declaration || ',

        data_value ' || _value_declaration || ',
       	
		data_note kapi_dtd_text_null_or_notempty,
        data_details kapi_dtd_text_null_or_notempty,
	
        data_inserted_at kapi_dtd_epoch_auto,
        data_updated_at kapi_dtd_epoch_auto
    );
    CREATE INDEX IF NOT EXISTS _idx_data_value_' || _table_name || ' ON ' || _table_name_full || ' (data_value);           
    CREATE INDEX IF NOT EXISTS _idx_inserted_at_' || _table_name || ' ON ' || _table_name_full || ' (data_inserted_at);
    CREATE INDEX IF NOT EXISTS _idx_updated_at_' || _table_name || ' ON ' || _table_name_full || ' (data_updated_at);
	';

    EXECUTE '
	SELECT public.kapi_tablefunc_updatedat(''' || _schema || ''', ''' || _table_name || ''' ,''data_updated_at'');
    ';

END;
$$
LANGUAGE plpgsql;


 -------------------- 
 -- src/tree/datatypes/01.02.tree.dt.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Reflect the underlying type of a structure. for defaults
-- if you customize the structure, Alter/duplicate the type so you can use this to get the underlying base
-- and use the proper functions to access the fields of the structure

DROP TYPE IF EXISTS public.kapi_dt_tree_tree;
CREATE TYPE public.kapi_dt_tree_tree AS(
    -- Node Fields
    node_id uuid
    ,node_group_id uuid
    ,node_path ltree
    ,node_key citext
    ,node_alias citext	
    ,node_path_to ltree 
    ,node_name ltree
    ,node_depth bigint
    ,node_weight integer      
    ,node_metadata jsonb
    ,node_data jsonb
    ,node_link_weight integer      
    ,node_link_metadata jsonb
    ,node_link_data jsonb        
    ,node_inserted_at bigint
    ,node_updated_at bigint      
    -- view fields    
    ,node_inserted_at_ts timestamp
    ,node_updated_at_ts timestamp
    ,node_parent_id uuid     
    ,node_descendants bigint		
    ,node_type text      
    ,node_link_state text
    -- tree gen
    ,tree_refreshed_at bigint
    ,tree_refreshed_at_ts timestamp
    ,tree_nodes_total bigint
    ,tree_nodes_updated_rn bigint
    ,tree_nodes_total_group bigint
    ,tree_nodes_updated_rn_group  bigint 
);

DROP TYPE IF EXISTS public.kapi_dt_tree_node;
CREATE TYPE public.kapi_dt_tree_node AS(
    node_id uuid
    ,node_group_id uuid
    ,node_path ltree
    ,node_key citext
    ,node_alias citext	
    ,node_path_to ltree 
    ,node_name ltree
    ,node_depth bigint
    ,node_weight integer      
    ,node_metadata jsonb
    ,node_data jsonb
    ,node_link_weight integer      
    ,node_link_metadata jsonb
    ,node_link_data jsonb        
    ,node_inserted_at bigint
    ,node_updated_at bigint 
);

DROP TYPE IF EXISTS public.kapi_dt_tree_data;
CREATE TYPE public.kapi_dt_tree_data AS(
    data_id uuid,
    data_node_id uuid,
    data_value text,
    data_note text,
    data_details text,
    data_inserted_at bigint,
    data_updated_at bigint
);


 -------------------- 
 -- src/tree/structures/01.02.tree.structure.mvw.tree.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
 * kapi_tree structures materialized view
 * Functions for basic tree visualizations
 * context: Tree Structure Materialized View
 **/
-- SELECT kapi_tree_structure_new_tree('categories.brands_nodes', 'categories','brands');
DROP FUNCTION IF EXISTS public.kapi_tree_structure_new_tree;
CREATE OR REPLACE FUNCTION public.kapi_tree_structure_new_tree(
    _source varchar,
    _schema varchar, 
    _table varchar
    ) 
RETURNS VOID
AS
$$
DECLARE
    _suffix varchar DEFAULT '_tree';
    _table_name varchar default  _table || _suffix;
    _table_name_full varchar default _schema || '.' || _table || _suffix;
BEGIN

    EXECUTE '
	CREATE SCHEMA IF NOT EXISTS ' || _schema || ';
    ';

    EXECUTE '
    CREATE MATERIALIZED VIEW IF NOT EXISTS ' || _table_name_full || ' AS
        WITH
        tree_source AS (
           SELECT * FROM ' || _source || ' 
        ),
        tree_base AS(
            SELECT
            this_node.node_id 
            ,this_node.node_group_id
            ,this_node.node_path
            ,this_node.node_key
            ,this_node.node_alias

            ,this_node.node_path_to
            ,this_node.node_name
            ,this_node.node_depth


            ,this_node.node_weight
            ,this_node.node_metadata
            ,this_node.node_data
            ,this_node.node_link_weight
            ,this_node.node_link_metadata
            ,this_node.node_link_data

            ,this_node.node_inserted_at
            ,this_node.node_updated_at

            ,public.kapi_time_epoch_to_timestamp(this_node.node_inserted_at) AS node_inserted_at_ts
            ,public.kapi_time_epoch_to_timestamp(this_node.node_updated_at) AS node_updated_at_ts

            ,parent_node.node_id AS node_parent_id

            ,
            (
                SELECT  
                count(*)
                FROM tree_source descendants
                WHERE 
                descendants.node_path <@ this_node.node_path 
                AND descendants.node_path != this_node.node_path
                AND descendants.node_group_id = this_node.node_group_id
            )::bigint AS node_descendants

            FROM tree_source this_node
            LEFT JOIN tree_source parent_node 
            ON (this_node.node_group_id = parent_node.node_group_id) 
            AND parent_node.node_path = this_node.node_path_to
            ORDER BY (this_node.node_group_id, this_node.node_path)
        ),
        tree_structure AS (
            SELECT 
            (
                CASE WHEN node_depth = 1 THEN
                    ''root''
                ELSE
                    CASE WHEN node_descendants = 0 THEN
                        ''leaf''
                    ELSE
                        ''node''
                    END
                END
            ) AS node_type
            ,
            (
                CASE WHEN node_depth = 1 THEN
                    ''root''
                ELSE
                    CASE WHEN node_parent_id IS NULL THEN
                        ''unlinked''
                    ELSE
                        ''linked''
                    END
                END
            ) AS node_link_state
            ,*
            ,public.kapi_time_epoch_now()::bigint AS tree_refreshed_at
            FROM tree_base
        ),
        tree_datatype AS(
            SELECT 
            -- node fields
            node_id::uuid
            ,node_group_id::uuid
            ,node_path::ltree
            ,node_key::citext
            ,node_alias::citext	
            ,node_path_to::ltree 
            ,node_name::ltree
            ,node_depth::bigint
            ,node_weight::integer      
            ,node_metadata::jsonb
            ,node_data::jsonb
            ,node_link_weight::integer      
            ,node_link_metadata::jsonb
            ,node_link_data::jsonb        
            ,node_inserted_at::bigint
            ,node_updated_at::bigint      
            -- view fields    
            ,node_inserted_at_ts::timestamp
            ,node_updated_at_ts::timestamp
            ,node_parent_id::uuid     
            ,node_descendants::bigint		
            ,node_type::text      
            ,node_link_state::text
            -- tree gen
            ,tree_refreshed_at::bigint
            ,public.kapi_time_epoch_to_timestamp(tree_refreshed_at)::timestamp AS tree_refreshed_at_ts
            FROM tree_structure
        ),
        tree_counts AS (
            SELECT 
            -- node fields
            node_id::uuid
            ,node_group_id::uuid
            ,node_path::ltree
            ,node_key::citext
            ,node_alias::citext	
            ,node_path_to::ltree 
            ,node_name::ltree
            ,node_depth::bigint
            ,node_weight::integer      
            ,node_metadata::jsonb
            ,node_data::jsonb
            ,node_link_weight::integer      
            ,node_link_metadata::jsonb
            ,node_link_data::jsonb        
            ,node_inserted_at::bigint
            ,node_updated_at::bigint      
            -- view fields    
            ,node_inserted_at_ts::timestamp
            ,node_updated_at_ts::timestamp
            ,node_parent_id::uuid     
            ,node_descendants::bigint		
            ,node_type::text      
            ,node_link_state::text
            -- tree gen
            ,tree_refreshed_at::bigint
            ,tree_refreshed_at_ts::timestamp
            ,(count(*) OVER ())::bigint AS tree_nodes_total
            ,(row_number() OVER (ORDER BY node_updated_at DESC))::bigint AS tree_nodes_updated_rn
            ,(count(*) OVER (PARTITION BY node_group_id))::bigint AS tree_nodes_total_group
            ,(row_number() OVER (PARTITION BY node_group_id ORDER BY node_updated_at DESC))::bigint AS tree_nodes_updated_rn_group
            FROM tree_datatype
        )
        SELECT 
            node_id::uuid
            ,node_group_id::uuid
            ,node_path::ltree
            ,node_key::citext
            ,node_alias::citext	
            ,node_path_to::ltree 
            ,node_name::ltree
            ,node_depth::bigint
            ,node_weight::integer      
            ,node_metadata::jsonb
            ,node_data::jsonb
            ,node_link_weight::integer      
            ,node_link_metadata::jsonb
            ,node_link_data::jsonb        
            ,node_inserted_at::bigint
            ,node_updated_at::bigint      
            -- view fields    
            ,node_inserted_at_ts::timestamp
            ,node_updated_at_ts::timestamp
            ,node_parent_id::uuid     
            ,node_descendants::bigint		
            ,node_type::text      
            ,node_link_state::text
            -- tree gen
            ,tree_refreshed_at::bigint
            ,tree_refreshed_at_ts::timestamp
            ,tree_nodes_total::bigint
            ,tree_nodes_updated_rn::bigint
            ,tree_nodes_total_group::bigint
            ,tree_nodes_updated_rn_group ::bigint 
        FROM tree_counts
        ORDER BY node_group_id, node_path ASC
        ;
    ';

    -- Replicate Node Indices
    -- + aditional
    EXECUTE '
    -- uk idx as pk for node_id
    CREATE UNIQUE INDEX IF NOT EXISTS _pk_' || _table_name || ' ON ' || _table_name_full || ' (node_id);

    -- UK index for other Unique Keys
    CREATE UNIQUE INDEX IF NOT EXISTS _uk_group_node_path_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_path);
    CREATE UNIQUE INDEX IF NOT EXISTS _uk_group_parent_node_alias_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_path_to, node_alias);
    CREATE UNIQUE INDEX IF NOT EXISTS _uk_group_parent_key_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_path_to, node_key);

    -- Same as node table
    CREATE INDEX IF NOT EXISTS _idx_path_' || _table_name || '  ON ' || _table_name_full || ' USING gist (node_path);
    CREATE INDEX IF NOT EXISTS _idx_path_to_' || _table_name || '  ON ' || _table_name_full || ' USING gist (node_path_to);
	CREATE INDEX IF NOT EXISTS _idx_group_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id);
    CREATE INDEX IF NOT EXISTS _idx_group_path_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_path);
    CREATE INDEX IF NOT EXISTS _idx_node_inserted_at_' || _table_name || ' ON ' || _table_name_full || ' (node_inserted_at);
    CREATE INDEX IF NOT EXISTS _idx_node_updated_at_' || _table_name || ' ON ' || _table_name_full || ' (node_updated_at);
    CREATE INDEX IF NOT EXISTS _idx_group_node_key_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_key);
    CREATE INDEX IF NOT EXISTS _idx_group_node_alias_' || _table_name || ' ON ' || _table_name_full || ' (node_group_id, node_alias);
    CREATE INDEX IF NOT EXISTS _idx_node_key_node_alias_fst_' || _table_name || ' ON ' || _table_name_full || ' USING gist (node_key, node_alias);
    CREATE INDEX IF NOT EXISTS _idx_node_key_node_alias_path_fst_' || _table_name || ' ON ' || _table_name_full || ' USING gist (node_key, node_alias, node_path);

    -- View indexes
    CREATE INDEX IF NOT EXISTS _idx_node_updated_at_ts_' || _table_name || ' ON ' || _table_name_full || ' (node_updated_at_ts);
	CREATE INDEX IF NOT EXISTS _idx_parent_id_' || _table_name || ' ON ' || _table_name_full || ' (node_parent_id);
    CREATE INDEX IF NOT EXISTS _idx_updated_rn_group_' || _table_name || ' ON ' || _table_name_full || ' (tree_nodes_updated_rn_group);

    ';

    -- Add refresg trigger and trigger function
    EXECUTE '
	SELECT public.kapi_tablefunc_mvw_refresh(''' || _source || ''',''' || _schema || ''', ''' || _table_name || ''');
    ';

END;
$$
LANGUAGE plpgsql;


 -------------------- 
 -- src/softdelete/01.softdelete.byschema.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

CREATE TABLE categories.brands_data_deleted (
	LIKE categories.brands_data, 
	PRIMARY KEY (id),
	deleted_at kapi_epoch
);
