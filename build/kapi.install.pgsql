-- Generated by Builder



 -------------------- 
 -- src/00.install.extensions.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- kapi required extensions 
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS btree_gist;

 -------------------- 
 -- src/time/01.time.module.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
@module kapi_time
Functions for Date & Time management
context: Common functions
*/


-- @function kapi_time_epoch_to_timestamp
-- @description Convert Epoch in Milliseconds to Timestamp Without Timezone in Milliseconds
-- @param _epoch_milliseconds bigint, Epoch in Milliseconds ( 13 digits )
-- @return _timestamp timestamp, Timestamp withour timezone in Milliseconds ( YYYY-MM-DD HH24:MI:SS.MS )
-- @usage
-- Epoch of CurrentTimestamp in milliseconds
-- SELECT kapi_time_epoch_to_timestamp( (date_part('epoch'::text, CURRENT_TIMESTAMP) * (1000)::double precision)::bigint );
-- Epoch in milliseconds to Timestamp in milliseconds
-- SELECT kapi_time_epoch_to_timestamp( 1656632664923 );  -- Timestamp in milliseconds = '2022-06-30 23:44:24.923'

DROP FUNCTION IF EXISTS kapi_time_epoch_to_timestamp;
CREATE OR REPLACE FUNCTION kapi_time_epoch_to_timestamp(
        _epoch_milliseconds bigint 
    )
RETURNS timestamp
AS
$$
DECLARE
    _timezone varchar default 'UTC';
    _timestamp timestamp;
    _divisor int default 1000;
BEGIN 
    _timestamp = (to_timestamp(TO_CHAR(TO_TIMESTAMP(_epoch_milliseconds / _divisor), 'YYYY-MM-DD HH24:MI:SS') || '.' || (_epoch_milliseconds % _divisor), 'YYYY-MM-DD HH24:MI:SS.MS')) AT TIME ZONE _timezone;
    RETURN _timestamp::timestamp;
END;
$$
LANGUAGE plpgsql;

-- @function kapi_time_timestamp_to_epoch
-- @description Convert Timestamp Without Timezone in Milliseconds to Epoch in Milliseconds
-- @param _timestamp timestamp, Timestamp withour timezone in Milliseconds ( YYYY-MM-DD HH24:MI:SS.MS )
-- @return _epoch_milliseconds bigint, Epoch in Milliseconds ( 13 digits )
-- @usage
-- epoch of CurrentTimestamp in milliseconds
-- SELECT kapi_time_timestamp_to_epoch(  CURRENT_TIMESTAMP::timestamp );
-- Timestamp in milliseconds to Epoch in milliseconds
-- SELECT kapi_time_timestamp_to_epoch( '2022-06-30 23:44:24.923' );  -- epoch in milliseconds = 1656632664923

DROP FUNCTION IF EXISTS kapi_time_timestamp_to_epoch;
CREATE OR REPLACE FUNCTION kapi_time_timestamp_to_epoch(
        _timestamp timestamp 
    )
RETURNS bigint
AS
$$
DECLARE
    _timezone varchar default 'UTC';
    _epoch_milliseconds bigint;
    _divisor int default 1000;
BEGIN
    _epoch_milliseconds = ((date_part('epoch'::text, _timestamp AT TIME ZONE _timezone) * (_divisor)::double precision))::bigint;
    RETURN _epoch_milliseconds;
END;
$$
LANGUAGE plpgsql;

 -------------------- 
 -- src/tree/datatypes/01.tree.datatype.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
 * kapi_tree datatypes
 **/

-- Structure to me use as return valeu for the materialized view operations
DROP TYPE IF EXISTS kapi_tree;
CREATE TYPE kapi_tree AS(
    tree_reference_id uuid,
    tree_node_path ltree,
    tree_node_parent_path ltree,
    tree_node_key ltree,
    tree_node_type citext,
    tree_link_state citext,
    tree_node_level bigint,
    tree_node_descendants bigint,
    tree_node_id uuid,
    tree_node_parent_id uuid,
    tree_node_metadata jsonb,
    tree_link_metadata jsonb,
    tree_node_inserted_at bigint,
    tree_node_updated_at bigint
);

-- Default Datatypes to bes used the kapi_tree_table_datatype

-- Date & time in Epoch milliseconds (milliseconds since the Unix epoch)
DROP DOMAIN IF EXISTS kapi_epoch;
CREATE DOMAIN kapi_epoch bigint ((date_part('epoch'::text, CURRENT_TIMESTAMP) * (1000)::double precision))::bigint;

-- Automaticly generated UUID
DROP DOMAIN IF EXISTS kapi_uuid_auto;
CREATE DOMAIN kapi_uuid_auto uuid NOT NULL DEFAULT uuid_generate_v4();

-- Not nullable UUID
DROP DOMAIN IF EXISTS kapi_uuid;
CREATE DOMAIN kapi_uuid uuid NOT NULL;

-- Ltree type
DROP DOMAIN IF EXISTS kapi_ltree;
CREATE DOMAIN kapi_ltree ltree NOT NULL;

-- default jsonb replica
DROP DOMAIN IF EXISTS kapi_json;
CREATE DOMAIN kapi_json jsonb NOT NULL DEFAULT '{}'::jsonb;

-- Simple structure to use as table type to be used in the creation of new trees
-- using custom types and domains to setup default values
DROP TYPE IF EXISTS kapi_tree_table_datatype;
CREATE TYPE kapi_tree_table_datatype AS(
    tree_node_id kapi_uuid_auto,
    tree_node_path kapi_ltree,
    tree_reference_id kapi_uuid,
    tree_node_metadata kapi_json,
    tree_link_metadata kapi_json,
    tree_node_inserted_at kapi_epoch,
    tree_node_updated_at kapi_epoch
);

 -------------------- 
 -- src/tree/structures/01.tree.structure.table.pgsql 
 -------------------- 

-- Copyright 2022 Rolando Lucio 

-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at

--     https://www.apache.org/licenses/LICENSE-2.0

-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

/*
 * kapi_tree structures table functions
 * Functions for basic tree structures
 * context: Tree Structure Table
 **/


-- @function kapi_tree_structure_table_new_nodes
-- @description 
-- Creates a new structure table
-- The tree_nodes table have the following structure:
-- tree_node_id uuid,                  -- Unique identifier for the node uuid.uuid_generate_v4()
-- tree_node_group uuid,               -- Group identifier for the node, could be used as tenant, 
                                       -- or similar to group the nodes with duplicate paths when needed.    
-- tree_reference_id uuid,             -- The Foreign key id to reference the data that will be linked to the tree node
-- tree_node_path ltree,               -- The path of the node in the tree
-- tree_node_metadata jsonb,           -- The metadata of the node
-- tree_link_metadata jsonb,           -- The metadata of the link related to the predecessor node
-- tree_node_inserted_at bigint,       -- The epoch time when the node was inserted in milliseconds
-- tree_node_updated_at bigint         -- The epoch time when the node was updated in milliseconds

-- A One To One relation To the data table is enforced by the tree_reference_id
-- Is highly recommended to use this table just for tree operations, not for data operations or biz logic

-- @param _schema The schema name
-- @param _table The table name
-- @param _suffix The suffix to add to the table name default _tree_nodes
-- @return create a new table in the schema and will sufix _tree_nodes [_schema].[_table][suffix]
-- @usage
-- SELECT kapi_tree_structure_table_new_nodes('categories','brands');
-- SELECT kapi_tree_structure_table_new_nodes('categories','brands','_mysuffix');

DROP FUNCTION IF EXISTS kapi_tree_structure_table_new_nodes;
CREATE OR REPLACE FUNCTION kapi_tree_structure_table_new_nodes(
    _schema varchar, 
    _table varchar,
    _suffix varchar DEFAULT '_tree_nodes'
    ) 
RETURNS VOID
AS
$$
DECLARE
    _table_name varchar default  _table || _suffix;
    _table_name_full varchar default _schema || '.' || _table || _suffix;
BEGIN
    -- Verify that the schema exists in the database
	EXECUTE '
	CREATE SCHEMA IF NOT EXISTS ' || _schema || ';
    ';
	
	EXECUTE '
	CREATE TABLE IF NOT EXISTS ' || _table_name_full || '(
        tree_node_id uuid NOT NULL,
        tree_node_group uuid,
        tree_reference_id uuid NOT NULL,
        tree_node_path ltree NOT NULL,
        tree_node_metadata jsonb NOT NULL DEFAULT ''{}''::jsonb,
        tree_link_metadata jsonb NOT NULL DEFAULT ''{}''::jsonb,
        tree_node_inserted_at bigint NOT NULL DEFAULT ((date_part(''epoch''::text, CURRENT_TIMESTAMP) * (1000)::double precision))::bigint,
        tree_node_updated_at bigint NOT NULL DEFAULT ((date_part(''epoch''::text, CURRENT_TIMESTAMP) * (1000)::double precision))::bigint,

        CONSTRAINT _pk PRIMARY KEY (tree_node_id),
        CONSTRAINT _uk_group_path UNIQUE (tree_node_group, tree_node_path),
        CONSTRAINT _uk_reference_id UNIQUE (tree_reference_id)

    );        
	
	CREATE INDEX IF NOT EXISTS _idx_path  ON ' || _table_name_full || ' USING gist (tree_node_path);
	CREATE INDEX IF NOT EXISTS _idx_group ON ' || _table_name_full || ' (tree_node_group);
    CREATE INDEX IF NOT EXISTS _idx_group_path ON ' || _table_name_full || ' USING btree (tree_node_group, tree_node_path);
    CREATE INDEX IF NOT EXISTS _idx_inserted_at ON ' || _table_name_full || ' (tree_node_inserted_at);
    CREATE INDEX IF NOT EXISTS _idx_updated_at ON ' || _table_name_full || ' (tree_node_updated_at);
	
	';
END;
$$
LANGUAGE plpgsql;


-- @function kapi_tree_structure_table_drop_nodes
-- @description
-- Drops a structure table
-- @param _schema_table The schema and table name
-- @return drop the table 
-- @usage
-- SELECT kapi_tree_structure_table_drop_nodes('categories.brands_tree_nodes');

DROP FUNCTION IF EXISTS kapi_tree_structure_table_drop_nodes;
CREATE OR REPLACE FUNCTION kapi_tree_structure_table_drop_nodes(
    _schema_table varchar
    )
RETURNS VOID
AS
$$
BEGIN
    EXECUTE '
    DROP TABLE IF EXISTS ' || _schema_table || ';
    ';
END;
$$
LANGUAGE plpgsql;
